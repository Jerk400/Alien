package AliEn::LQ::CREAM;

use AliEn::LQ::LCG;
use vars qw (@ISA);
@ISA = qw( AliEn::LQ::LCG);

use strict;
use AliEn::Database::CE;
use File::Basename;
use Net::LDAP;
use AliEn::TMPFile;
use POSIX ":sys_wait_h";
use Sys::Hostname;

sub initialize {
   my $self=shift;
   $self->{DB}=AliEn::Database::CE->new();
   $ENV{X509_CERT_DIR} and $self->{LOGGER}->debug("LCG","X509: $ENV{X509_CERT_DIR}");
   my $host= `/bin/hostname` || $self->{CONFIG}->{HOST};
   chomp $host;
   $self->{CONFIG}->{VOBOX} = $host.':8084';
   $ENV{ALIEN_CM_AS_LDAP_PROXY} and $self->{CONFIG}->{VOBOX} = $ENV{ALIEN_CM_AS_LDAP_PROXY};
   $self->info("This VO-Box is $self->{CONFIG}->{VOBOX}, site is \'$ENV{SITE_NAME}\'");
   $self->{CONFIG}->{VOBOXDIR} = "/opt/vobox/\L$self->{CONFIG}->{ORG_NAME}";
   $self->{UPDATECLASSAD} = 0;
   
   my $cmds = {  SUBMIT_CMD     => 'glite-ce-job-submit',
                 STATUS_CMD     => 'glite-ce-job-status',
		 KILL_CMD       => 'glite-ce-job-cancel',
		 CLEANUP_CMD    => '',
                 DELEGATION_CMD => 'glite-ce-delegate-proxy'};
			 
   $self->{$_} = $cmds->{$_} || $self->{CONFIG}->{$_} || '' foreach (keys %$cmds);
   unless ($self->readCEList()) {
      $self->{LOGGER}->error("LCG","Error reading CE list");
      return;
   } 
   $self->renewProxy(172800);
   $self->{CONFIG}->{DELEGATION_ID} = "$self->{CONFIG}->{CE_FULLNAME}:".time();
   foreach ( @{$self->{CONFIG}->{CE_LCGCE_FLAT_LIST}} ) {
     (my $CE, undef) = split /\//;
     my @command = ($self->{DELEGATION_CMD},"-e",$CE,
                                            "-d","$self->{CONFIG}->{DELEGATION_ID}");   
     my @output = $self->_system(@command);
     my $error = $?;
     if ($error) {
       $self->{LOGGER}->error("LCG","Error $error delegating the proxy to $CE");
       return;
     }
     $self->{DELEGATIONTIME} = time;
   }
   return 1;
}

sub submit {
  my $self = shift;
  my $jdl = shift;
  my $command = shift;

  my $startTime = time;
  my @args=();
  $self->{CONFIG}->{CE_SUBMITARG_LIST} and @args = @{$self->{CONFIG}->{CE_SUBMITARG_LIST}};
  my $jdlfile = $self->generateJDL($jdl, $command);
  $jdlfile or return;
  
  #pick a random CE from the list
  my $theCE = $self->{CONFIG}->{CE_LCGCE_FLAT_LIST}->[int(rand(@{$self->{CONFIG}->{CE_LCGCE_FLAT_LIST}}))];
  push @args, ("-r", $theCE);
  push @args, ("-D", "$self->{CONFIG}->{DELEGATION_ID}");
  $self->renewProxy(172800,172700);
  $self->renewDelegation(72000); 

  $self->info("Submitting to LCG with \'@args\'.");
  my $now = time;
  my $logFile = AliEn::TMPFile->new({filename=>"job-submit.$now.log"}) or return;

  my $contact = '';
  $contact = $self->wrapSubmit($logFile, $jdlfile, @args);
  $self->{LAST_JOB_ID} = $contact;
  return unless $contact;
  $self->info("LCG JobID is $contact");
  open JOBIDS, ">>$self->{CONFIG}->{LOG_DIR}/CE.db/JOBIDS";
  print JOBIDS "$now,$contact\n";
  close JOBIDS;

  my $submissionTime = time - $startTime;
  $self->info("Submission took $submissionTime sec.");
  return 0;
}

sub wrapSubmit {
  my $self = shift;
  my $logFile = shift;
  my $jdlfile = shift;
  my @args = @_ ;  
  my @command = ( $self->{SUBMIT_CMD}, "--noint", "--nomsg");
  @command = ( @command, "--logfile", $logFile, @args, "$jdlfile");
  my @output = $self->_system(@command);
  my $error = $?;
  (my $jobId) = grep { /https:/ } @output;
  return if ( $error || !$jobId);
  $jobId =~ m/(https:\/\/[A-Za-z0-9.-]*:8443\/CREAM\d+)/;
  $jobId = $1; chomp $jobId;
  return $jobId;
}

sub generateJDL {
  my $self = shift;
  my $ca = shift;
  my $command=shift;
  my $bdiiReq=shift;
  my $requirements = $self->translateRequirements($ca, $bdiiReq);

  my $exeFile = AliEn::TMPFile->new({filename=>"dg-submit.$$.sh"})
    or return;

  open( BATCH, ">$exeFile" )
    or print STDERR "Can't open file '$exeFile': $!"
      and return;
  print BATCH "\#!/bin/sh
\# Script to run AliEn on LCG
\# Automatically generated by AliEn running on $ENV{HOSTNAME}

export OLDHOME=\$HOME
export HOME=`pwd`
export ALIEN_LOG=$ENV{ALIEN_LOG}
echo --- hostname, uname, whoami, pwd --------------
hostname
uname -a
whoami
pwd
echo --- ls -la ------------------------------------
ls -lart
echo --- df ----------------------------------------
df -h
echo --- free --------------------------------------
free

";

  my $exec="alien";
  if ( $self->{CONFIG}->{CE_INSTALLMETHOD}) {
    $exec= "\$HOME/bootsh /opt/alien/bin/alien";
    my $method="installWith".$self->{CONFIG}->{CE_INSTALLMETHOD};
    eval {
      ($exec, my $print)=$self->$method();
      print BATCH $print;
    };
    if ($@){
      $self->info("Error calling $method: $@");
      return;

    };
  } else {
    print BATCH "export PATH=\$PATH:\$VO_ALICE_SW_DIR/alien/bin\n";
  }

  print BATCH "
cd \${TMPDIR:-.}
echo --- env ---------------------------------------
echo \$PATH
echo \$LD_LIBRARY_PATH

echo --- alien --printenv --------------------------
$exec -printenv
echo --- alien proxy-info ---------------------------
$exec proxy-info
echo --- Run ---------------------------------------
$exec RunAgent
rm -f dg-submit.*.sh
ls -lart
";

  close BATCH or return;
  
  my $jdlFile = AliEn::TMPFile->new({filename=>"dg-submit.$$.jdl"})
    or return;
  open( BATCH, ">$jdlFile" )
    or print STDERR "Can't open file '$jdlFile': $!"
      and return;
  my $voName=$ENV{ALIEN_VOBOX_ORG}|| $self->{CONFIG}->{ORG_NAME};

  my $now = gmtime()." "."$$"; 
  $now =~ s/\s+/\_/g;
  mkdir "/tmp/$now", 0755 or $self->{LOGGER}->warning("CREAM","The directory for the CREAM output cannot be created");
  my $host_name = hostname;
  print BATCH "\# JDL automatically generated by AliEn
  Executable = \"/bin/sh\";
  Arguments = \"-x dg-submit.$$.sh\";
  StdOutput = \"std.out\";
  StdError = \"std.err\";
  InputSandbox = {\"$exeFile\"};
  #OutputSandbox = { \"std.err\" , \"std.out\" };
  #Outputsandboxbasedesturi = \"gsiftp://$host_name:2811/tmp/$now\";
  Environment = {\"ALIEN_CM_AS_LDAP_PROXY=$self->{CONFIG}->{VOBOX}\",\"ALIEN_JOBAGENT_ID=$ENV{ALIEN_JOBAGENT_ID}\", \"ALIEN_USER=$ENV{ALIEN_USER}\"};
  ";

  print BATCH "Requirements = $requirements;\n" if $requirements;
  close BATCH;
  return $jdlFile;
}

sub getAllBatchIds {
  my $self = shift;
  return getCREAMStatus('RUNNING:REALLY-RUNNING:REGISTERED:PENDING:IDLE:HELD',
                        $self->{CONFIG}->{CE_LCGCE_FIRSTS_LIST});
}

sub cleanUp {
  return 1;
}

sub needsCleaningUp {
  return 0;
}

sub getNumberRunning() {
  my $self = shift;
  my $run  = $self->getCREAMStatus('RUNNING:REALLY-RUNNING:HELD',$self->{CONFIG}->{CE_LCGCE_FIRSTS_LIST});
  my $wait = $self->getCREAMStatus('REGISTERED:PENDING:IDLE',$self->{CONFIG}->{CE_LCGCE_FIRSTS_LIST});
  $run or $run=0;
  $wait or $wait=0;
  my $value = $self->getQueueStatus();
  $value or $value = 0;
  my ($runIS,$waitIS) = $self->getCEInfo(qw(GlueCEStateRunningJobs GlueCEStateWaitingJobs ));
  $runIS or $runIS=0;
  $waitIS or $waitIS=0;
  $self->info("Jobs running, waiting: $run,$wait  from CREAM, $runIS,$waitIS from BDII, $value from local DB");
  return $run+$wait;    
}

sub getNumberQueued() {
  my $self=shift;
  my $wait = $self->getCREAMStatus('REGISTERED:PENDING:IDLE',$self->{CONFIG}->{CE_LCGCE_FIRSTS_LIST});
  $wait or $wait=0;
  my $value = $self->{DB}->queryValue("SELECT COUNT (*) FROM JOBAGENT where status='QUEUED'");
  $value or $value = 0;
  (my $waitIS) = $self->getCEInfo(qw(GlueCEStateWaitingJobs));
  $waitIS or $waitIS=0;
  $self->info("Queued: $wait from CREAM, $waitIS from BDII, $value from local DB");
  return $wait;
}

#
#---------------------------------------------------------------------
#

sub getCREAMStatus {
  my $self = shift;
  my $statusString = shift;
  # Active states: 'RUNNING:REALLY-RUNNING:REGISTERED:PENDING:IDLE:HELD'
  # Final states:  'DONE-OK:DONE-FAILED:CANCELLED:ABORTED'
  # There is also: 'UNKNOWN'
  $statusString or return;
  my $CEList = shift;
  $CEList or return;
  my @allJobs = ();
  my $logfile = AliEn::TMPFile->new({ ttl => '12 hours'});
  foreach my $CE ( @$CEList ) {
    (my $endpoint, undef) = split /\//,$CE;
    $self->info("Asking $CE for jobs that are $statusString");
    my @output=$self->_system($self->{STATUS_CMD}, "--nomsg",
                                                   "--logfile", $logfile,
	  					   "--endpoint", $endpoint,
		    				   "--all",
						   "--status", $statusString);
    my $nJobs  = grep (/^\*\*\*\*\*\*  JobID=/,@output);
    $self->info("Got $nJobs jobIds.");                                             
    foreach (@output) {
      next unless m/^\*\*\*\*\*\*  JobID=/;
      chomp;
      (my $id = $_) =~ s/^.*\[//;
      $id  =~ s/].*$//;
      push (@allJobs, $id);
    } 
  }
  return @allJobs;
}

sub renewDelegation {
  my $self = shift;
  my $interval = shift;
  $interval or $interval = 2*60*60; #2 hours 
  my $still = $interval-(time-$self->{DELEGATIONTIME});
  if ( $still<=0 ) {
    $self->info("Renewing proxy delegation for all CEs");
    foreach ( @{$self->{CONFIG}->{CE_LCGCE_FLAT_LIST}} ) {
      (my $CE, undef) = split /\//;
      my @command = ("glite-ce-proxy-renew","-e",$CE,
                                            "-d","$self->{CONFIG}->{DELEGATION_ID}");   
      my @output = $self->_system(@command);
      my $error = $?;
      if ($error) {
        $self->{LOGGER}->error("LCG","Error $error renewing the delegation to $CE");
      return;
     }
   }
    $self->{DELEGATIONTIME} = time;
  } else {
    $self->debug(1,"No need to renew the delegation yet, still $still seconds to go (requested interval is $interval)");
  }
  return 1;
}

return 1;

